import org.antlr.v4.runtime.tree.ParseTreeVisitor;
import org.antlr.v4.runtime.*;
import org.antlr.v4.runtime.tree.*;
import org.antlr.v4.runtime.CharStreams;
import java.io.IOException;
import java.util.*;

public class main {
    public static void main(String[] args) throws IOException{

	// we expect exactly one argument: the name of the input file
	if (args.length!=1) {
	    System.err.println("Please give as input argument a filename\n");
	    System.exit(-1);
	}
	String filename=args[0];

	// open the input file
	CharStream input = CharStreams.fromFileName(filename);
	    //new ANTLRFileStream (filename); // depricated
	
	// create a lexer/scanner
	implLexer lex = new implLexer(input);
	
	// get the stream of tokens from the scanner
	CommonTokenStream tokens = new CommonTokenStream(lex);
	
	// create a parser
	implParser parser = new implParser(tokens);
	
	// and parse anything from the grammar for "start"
	ParseTree parseTree = parser.start();

	// Construct the abstract syntax tree for the main block
	ASTMaker astMaker = new ASTMaker();
	Command mainblock=(Command)astMaker.visit(parseTree);

	// run the main block with a fresh environment 
	//mainblock.eval(new Environment());
	
	String header=
	    "; ModuleID = 'generatedLLVMcode'\n\n"+
	    "@.str = private constant [4 x i8] c\"%f\\0A\\00\"\n\n"+
	    "@.strerr = private constant [16 x i8] c\"Out of bounds!\\0A\\00\"\n\n"+
	    "define void @print(double %d) nounwind ssp {\n"+
	    "  %1 = alloca double\n"+
	    "  store double %d, double* %1\n"+
	    "  %2 = load double, double* %1\n"+
	    "  %cast210 = getelementptr inbounds [4 x i8], [4 x i8]* @.str, i64 0, i64 0\n"+
	    "  %3 = call i64 (i8*, ...) @printf(i8* %cast210, double %2)\n"+
	    "  ret void\n"+
	    "}\n\n"+
	    "define void @error() nounwind ssp {\n"+
	    "  %cast210 = getelementptr inbounds [16 x i8], [16 x i8]* @.strerr, i64 0, i64 0\n"+
	    "  %1 = call i64 (i8*, ...) @printf(i8* %cast210)\n"+
	    "  ret void\n"+
	    "}\n\n"+
	    "declare i64 @printf(i8*, ...)\n"+
	    "declare i8* @malloc(i64) #1\n\n"+
	    "define i64 @main() nounwind ssp {\n\n";
	String trailer=
	    "ret i64 0\n}\n";

	
	Symtab env = new Symtab();
	
	// Generate code for allocating all variables:
	//String allocation=mainblock.allocate(env);
	String allocation="";

	// Typecheck the program first (populating also the symtab):
	mainblock.typecheck(env);
	
	// compile the main block with a fresh symbol table
	String compiled=mainblock.compile(env);
	System.out.println(header+"\n\n"
			   +compiled+"\n\n"
			   +trailer);
    }
    
}

// We write an interpreter that implements interface
// "implVisitor<T>" that is automatically generated by ANTLR
// This is parameterized over a return type "<T>" which is in our case
// simply a Double.
/*
class Interpreter extends AbstractParseTreeVisitor<Double> implements implVisitor<Double> {

    static Environment env=new Environment();
    static String varname="";
    
    public Double visitStart(implParser.StartContext ctx){
	for(implParser.CommandContext c:ctx.cs) visit(c);
	return null;
    };

    public Double visitSingleCommand(implParser.SingleCommandContext ctx){
	return visit(ctx.c);
    }

    public Double visitMultipleCommands(implParser.MultipleCommandsContext ctx){
	for(implParser.CommandContext c:ctx.cs) visit(c);
	return null;
    }
    
    public Double visitAssignment(implParser.AssignmentContext ctx){
 	Double v=visit(ctx.e);
	visit(ctx.l);
	env.setVariable(varname,v);
	return null;
    }
    
    public Double visitForLoop(implParser.ForLoopContext ctx){
	String x=ctx.x.getText();
	Double v1=visit(ctx.e1);
	Double v2=visit(ctx.e2);
	env.setVariable(x,v1);
	while(!env.getVariable(x).equals(v2)){
	    visit(ctx.p);
	    env.setVariable(x,env.getVariable(x)+1);
	}
	return null;
    }
    public Double visitIf(implParser.IfContext ctx){
	if (visit(ctx.c).equals(1.0)) visit(ctx.p);
	return null;
    }
    public Double visitArray(implParser.ArrayContext ctx){
	Double v=visit(ctx.e);
	varname=ctx.a.getText()+"["+v+"]";
	return null;
    }
    public Double visitLefthandside(implParser.LefthandsideContext ctx){
	visit(ctx.l);
	return env.getVariable(varname);
    }
    public Double visitDisjunction(implParser.DisjunctionContext ctx){
	if(visit(ctx.c1).equals(1.0) || visit(ctx.c2).equals(1.0))
	    return 1.0;
	return 0.0;
    }
    public Double visitParenthesisCondition(implParser.ParenthesisConditionContext ctx){
	return visit(ctx.c);
    }
    public Double visitNegation(implParser.NegationContext ctx){
	if (visit(ctx.c).equals(1.0)) return 0.0;
	return 1.0;					  
    }
    
    public Double visitEqual(implParser.EqualContext ctx){
 	Double v1=visit(ctx.e1);
	Double v2=visit(ctx.e2);
	if (v1.equals(v2))  return 1.0;
	else return 0.0;
    }
    public Double visitSmaller(implParser.SmallerContext ctx){Double v1=visit(ctx.e1);
	Double v2=visit(ctx.e2);
	if (v1.doubleValue()<v2.doubleValue())  return 1.0;
	else return 0.0;
    }
    public Double visitConjunction(implParser.ConjunctionContext ctx){
	if(visit(ctx.c1).equals(1.0) && visit(ctx.c2).equals(1.0))
	    return 1.0;
	return 0.0;
    }
    
    public Double visitOutput(implParser.OutputContext ctx){
	Double v=visit(ctx.e);
	System.out.println(v);
	return null;
    }

    public Double visitWhileLoop(implParser.WhileLoopContext ctx){
	while(visit(ctx.c).equals(1.0)){
	    visit(ctx.p);
	}
	return null;
    }
    
    public Double visitParenthesis(implParser.ParenthesisContext ctx){
	return visit(ctx.e);
    };
    
    public Double visitVariable(implParser.VariableContext ctx){
	varname=ctx.x.getText();
	return null;
    };
    
    public Double visitAddition(implParser.AdditionContext ctx){
	if (ctx.o.getText().equals("+"))
	    return visit(ctx.e1)+visit(ctx.e2);
	return visit(ctx.e1)-visit(ctx.e2);
    };

    public Double visitMultiplication(implParser.MultiplicationContext ctx){
	if (ctx.o.getText().equals("*"))
	    return visit(ctx.e1)*visit(ctx.e2);
	return visit(ctx.e1)/visit(ctx.e2);
    };

    public Double visitConstant(implParser.ConstantContext ctx){
	return Double.parseDouble(ctx.c.getText()); 
    };

    public Double visitUnequal(implParser.UnequalContext ctx){
	Double v1=visit(ctx.e1);
	Double v2=visit(ctx.e2);
	if (v1.equals(v2))  return 0.0;
	else return 1.0;
    }
    public Double visitDeclaration(implParser.DeclarationContext ctx){ return null; }
}
*/

class ASTMaker extends AbstractParseTreeVisitor<AST> implements implVisitor<AST> {

    static Environment env=new Environment();
    
    public AST visitStart(implParser.StartContext ctx){
	Command result=new Nop();
	for(implParser.DeclarationContext d:ctx.decs)
	    result=new Sequence(result,(Command)visit(d));
	    
	for(implParser.CommandContext c:ctx.cs)
	    result=new Sequence(result,(Command)visit(c));
	return result;
    };

    public AST visitSingleCommand(implParser.SingleCommandContext ctx){
	return visit(ctx.c);
    }

    public AST visitMultipleCommands(implParser.MultipleCommandsContext ctx){
	Command result=new Nop();
	for(implParser.CommandContext c:ctx.cs) result=new Sequence(result,(Command)visit(c));
	return result;
    }
    
    public AST visitAssignment(implParser.AssignmentContext ctx){
	return visit(ctx.l);
    }

    public AST visitAccess(implParser.AccessContext ctx){
	List<String> acc=new ArrayList<String>();
	for(Token a:ctx.as) acc.add(a.getText());
	return new Access(ctx.base.getText() ,acc);
    }
    
    public AST visitAssign(implParser.AssignContext ctx){
	AST lhs=visit(ctx.l);
	Expr e=(Expr)visit(ctx.e);
	if(lhs instanceof Variable){
	    Variable x = (Variable) lhs;
	    return new Assignment(x.name,e);
	}
	else {
	    if (lhs instanceof Array){
		Array a = (Array) lhs;
		return new ArrayAssignment(a.a,a.index,e);
	    }
	    else{ // Must be Access
		Access a = (Access) lhs;
		return new StructAccess(a,e);
	    }
	}
    }
    
    public AST visitSpecification(implParser.SpecificationContext ctx){
	List<Assignment> assigns=new ArrayList<Assignment>();
	for(implParser.AssignContext a:ctx.fields)
	    assigns.add((Assignment) visit(a));
	return new Specification(ctx.structname.getText(),
				 assigns);
    }

	
    public AST visitOutput(implParser.OutputContext ctx){
	return new Output((Expr)visit(ctx.e));
    }

    public AST visitWhileLoop(implParser.WhileLoopContext ctx){
	return new While((Condition)visit(ctx.c),(Command)visit(ctx.p));
    }
    
    public AST visitParenthesis(implParser.ParenthesisContext ctx){
	return visit(ctx.e);
    };
    
    public AST visitVariable(implParser.VariableContext ctx){
	return new Variable(ctx.x.getText());
    };
    
    public AST visitAddition(implParser.AdditionContext ctx){
	if (ctx.o.getText().equals("+"))
	    return new Addition((Expr)visit(ctx.e1),(Expr)visit(ctx.e2));
	else 
	    return new Subtraction((Expr)visit(ctx.e1),(Expr)visit(ctx.e2));
    };

    public AST visitMultiplication(implParser.MultiplicationContext ctx){
	if (ctx.o.getText().equals("*"))
	    return new Multiplication((Expr)visit(ctx.e1),(Expr)visit(ctx.e2));
	else 
	    return new Division((Expr)visit(ctx.e1),(Expr)visit(ctx.e2));
    };

    public AST visitConstant(implParser.ConstantContext ctx){
	return new Constant(Double.parseDouble(ctx.c.getText())); 
    };

    public AST visitUnequal(implParser.UnequalContext ctx){
	return new Unequal((Expr)visit(ctx.e1),(Expr)visit(ctx.e2));
    }
   
    public AST visitSmaller(implParser.SmallerContext ctx){
	return new Smaller((Expr)visit(ctx.e1),(Expr)visit(ctx.e2));
    }
    public AST visitConjunction(implParser.ConjunctionContext ctx){
	return new Conjunction((Condition)visit(ctx.c1),(Condition)visit(ctx.c2));
    }
    public AST visitEqual(implParser.EqualContext ctx){
	return new Equal((Expr)visit(ctx.e1),(Expr)visit(ctx.e2));
    }
    public AST visitNegation(implParser.NegationContext ctx){
	return new Negation((Condition)visit(ctx.c));
    }

    public AST visitParenthesisCondition(implParser.ParenthesisConditionContext ctx){
	return visit(ctx.c); // we can forget about parentheses here
    }
    public AST visitDisjunction(implParser.DisjunctionContext ctx){
	return new Disjunction((Condition)visit(ctx.c1),(Condition)visit(ctx.c2));
    }
    public AST visitLefthandside(implParser.LefthandsideContext ctx){
	return visit(ctx.l);
    }
    public AST visitArray(implParser.ArrayContext ctx){
	return new Array(ctx.a.getText(),(Expr) visit(ctx.e));
    }
    public AST visitIf(implParser.IfContext ctx){
	return new If((Condition)visit(ctx.c),(Command)visit(ctx.p));	
    }
    public AST visitForLoop(implParser.ForLoopContext ctx){
	String x = ctx.x.getText();
	Expr e1 = (Expr) visit(ctx.e1);
	Expr e2 = (Expr) visit(ctx.e2);
	Command c = (Command) visit(ctx.p);
	return
	    new Sequence(
	      new Assignment(x,e1),
	      new While(
		new Unequal(new Variable(x),e2),
		new Sequence(c,
		  new Assignment(
  		    x,new Addition(new Variable(x),new Constant(1.0)))))); 
    }
    public AST visitDeclaration(implParser.DeclarationContext ctx){
	String a = ctx.x.getText();
	int s = Integer.parseInt(ctx.c.getText());
	return new Declaration(a,s);
    }
}
